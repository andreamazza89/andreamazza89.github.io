---
layout: post
title: This is incredible! (Makers week 1)
date: 2016-05-28 09:09:14.000000000 +01:00
type: post
published: true
status: publish
---
<p class="p1"><img class=" size-full wp-image-486 aligncenter" src="{{ site.baseurl }}/assets/bloomtaxonomy.jpg" alt="Bloomtaxonomy"  /></p>
<p class="p1"><span class="s1">Here is a beautiful thing we were taught this week: in an Agile community, the only way someone can grow is by helping someone else grow. This is the foundation of mentorship. Isn't this great? We help each other grow and as a result we all improve as a community; beautiful. I might cry :)</span></p>
<p class="p1"><span class="s1">Here is a quick example our (awesome) coach <a href="https://github.com/sjmog" target="_blank">Sam</a> gave us, using Bloom's model pictured above. We are all different, and if two individuals are at a different levels of learning, say apply and understand, if the one who is ahead helps the one behind apply the concepts they understand, that will have helped them move one move to the apply level, the other on the analyse level, as analysis is required in order to properly explain how to apply something to someone. Both parties are winners.</span></p>
<p class="p1"><span class="s1">All this ties in with concepts of open source, whereby community collaboration is a very powerful tool.</span></p>
<p class="p1"><span class="s1">OK, one week of Makers main course has gone and I am extremely happy about this. If you are reading this blog trying to make up your mind about makers, DO IT! It is awesome. It feels like time flew yet at the same time felt like a month rather than a week due to the huge amount of things we have learned.</span></p>
<p class="p1"><span class="s1">Makers is serious business, yet everyone is relaxed, helpful and nice. It feels like home rather than work.</span></p>
<p class="p1"><span class="s1">This is my daily routine: wake up (7am), go to Makers (8am) code, code, code, pingpong, code code, lunch, code code, code, pingpong, dinner, code code, sleep. It is now the weekend, and guess what I will be up to? I cannot get enough; there is always something else to lea</span><span class="s1">rn and something that could be done better. It might sound daunting to some, but I love it: we are on a path of constant improvement for the rest of our lives.</span></p>
<p class="p1"><span class="s1">Among the gazillion things we have learned this week, one that is almost completely new to me and I particularly liked is the BehaviourDrivenDevelopment (BDD) rationale. I will try to explain.</span></p>
<p class="p1"><span class="s1">For any piece of software, we have a user, some sort of machine the user 'speaks' (interfaces) to, and a programmer who told the machine what to do. Simple. By the way, the machine could be a website, a mobile app, an ATM, a self-driving car, etc...The only point in the machine and the programmer existing is because the user needs the machine to do something useful, be that a game, payment, calculator, train information, you name it.</span></p>
<p class="p1"><span class="s1">Now, when a user comes out with the requirement for a new piece of software, the most logical place to start is what the user wants from this new thing. Seems logical when put in perspective but it is easy for a software developer to loose sight of this and implement feat</span><span class="s1">ures for the sake of it, even if the user did not ask for them. This is not over delivering, this is complicating things, making the process slower and potentially annoying the user with a product they did not ask for.</span></p>
<p class="p1"><span class="s1">Anyway, in BehaviourDrivenDevelopment (I hate acronims) the process of delivering a piece of software is driven by the user requirements. These are condensed into 'User stories', which read something like this:</span></p>
<blockquote>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>As an air traffic controller </span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>So I can get passengers to a destination</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>I want to instruct a plane to land at an airport and confirm that it has landed</span></p>
<p class="p1"><span class="s1"><span class="Apple-converted-space">  </span>......</span></p>
</blockquote>
<p class="p1"><span class="s1">(this is from this weekend's challenge at Makers by the way) Succinct, nice and clear. Delivering the features described in a user story should remain the focus throughout the process. They might change as the Client develops their understanding of what they need or develop new requirements, but that is ok, we just need to update the user stories.</span></p>
<p class="p1"><span class="s1">Now the user stories help the developers create 'feature tests'. These could be described as trying the software out before it even exists. This will generate errors as the machine does not know what to do. Solving those errors is how we write software.</span></p>
<p class="p1"><span class="s1">For example, in the airport traffic control user story above, a feature test could be writing something like this: &lt;Plane ID:333215152; land!&gt;. Our expectation is for the machine to confirm that the plane has landed, something like &lt;ID:333215152 status: landed&gt;, however, </span><span class="s1">the machine will complain that it does not know what a plane is, let alone IDs and landing!</span></p>
<p class="p1"><span class="s1">The next step in BehaviourDrivenDevelopment is to move onto what is called Unit test, and the domain of TestDrivenDevelopment. This is very similar to BDD, but more 'zoomed in' on the individual components of a program. Much like we have done before, ahead of writing any </span><span class="s1">working code, tests are written, clearly outlining our expectations on the code. </span></p>
<p class="p1"><span class="s1">Going back to the example we might now write test to check that a plane and airport exist, and the plane knows what land means and how to do it. It is easy to see that there are several Unit tests for one feature test.</span></p>
<p class="p1"><span class="s1">This process is cyclic, as we keep writing tests that fail, then make them work by writing code, something else fails, we make it work, and so on until we can go back to our initial feature test (in this example we wanted to land a specific plane) and it magically works.</span></p>
<p class="p1"><span class="s1">Awesome, I like it and it makes a lot of sense. If this was not enough, there are (at least) two more intrinsic advantages: the code we write comes 'pre-tested', as opposed to writing something and then figuring out how to test it and the tests act as documentation on the</span><span class="s1"> code, as they outline all the requirements. Wow, I am impressed!!</span></p>
<p class="p1"><span class="s1">That is it. As a side note I am fully converted to vim and have started picking up tmux, which is exciting!</span></p>
<p class="p1"><span class="s1">Ciao</span></p>
