---
layout: post
title: 8th Light apprenticeship - Day Eighty-five
categories: 8thLight apprenticeship
---

This week I am back to learning Clojure. My eyes have not yet adapted to Lisp but
I am sure it is only a matter of time. Well, as long as I spend that time reading
and writing Clojure, which I plan to.

Here is a cool thing about Clojure I found in this [book](http://www.braveclojure.com/clojure-for-the-brave-and-true/):

{% highlight clojure %}

  (def sum #(reduce + %))
  (def avg #(/ (sum %) (count %)))
  (defn stats
    [numbers]
    (map #(% numbers) [sum count avg]))

  (stats [3 4 10])
  ; => (17 3 17/3)

{% endhighlight %}

Well, it is not exclusive to Clojure, but I have not seen this before. I like how
the snippet above really makes you think of first-class functions.
We say a language has first class functions when functions can be passed around
like data. When using the `map` function, you normally expect a function and a
collection. `map` goes through each item in the collection and applies the given
function to each item, returning a new collection with the outputs generated by
the function. So I normally think of `map` as transforming a data structure,
converting each element based on the given function. This is what is happening
in the example above, however the transformation is __from__ _function_ (a type of data)
__to__ _long_ or _ratio_ (other types of data). The anonymous function given to
`map` applies the input function (`sum` `count` `avg`) to the given collection of
integers (`numbers`)

Crazy stuff.
